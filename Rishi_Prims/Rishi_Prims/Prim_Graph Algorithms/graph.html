<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Prims Algo</title>
    <link rel="stylesheet" href="./Style.css">

    
    <script type="text/javascript" src="../lib/p5/p5.js"></script>
    <script type="text/javascript" src="../src/animation.js"></script>
    <script type="text/javascript" src="../src/frams.js"></script>
    <script type="text/javascript" src="../src/prim_text.js"></script>
    <script type="text/javascript" src="../src/clock.js"></script>
    <script type="text/javascript" src="../src/prim_utils.js"></script>
    <script type="text/javascript" src="../src/prim_brain.js"></script>

    
    <script type="text/javascript" src= "graph.js"></script>
    <script type="text/javascript" src= "prim.js"></script>
</head>
<style>
    p{
        font-size: 1.5em;
    }
    h1
    {
        font-size: 3em;
    }
    h3{
        font-size: 2em;
    }
    h4{
        font-size: 1.5em;
    }

</style>
<body>
    <h1 style="text-align:center">
        Topic - Prim's Algorithm
    </h1>
    <div class="details">
       <ul>
        <li class="list-items">
            Name - Rishi Gupta 
        </li>
        <li class="list-items">
            NUID - 002921999
        </li>
        <!-- this place -->
        <h3>
            What is Prim's Algorithm
        </h3>
        <p> Prim's Algorithm was created to discover the MST (minimum spanning tree)  across a connected, weighted undirected graph.
            Prims Algorithm is based on greedy algorithm.  This signifies that the technique finds the minimal weight "tree" (a structure without cycles) that connects all of the vertices via a subset of all available edges.
        </p>
        
        <h3>
         Time and Space complexity of the Algorithm: 
        </h3>
        <p> The time complexity of Prim's method using the adjacency matrix, is O(V^2), where V is the number of vertices in the graph. By employing Fibonacci heaps, this time complexity may be reduced to O(E + Vlog V). By using the binary heap and adjacency list this time complexity may be reduced to O(E log V)
            The total complexity of space is of the order O(V+E).
            
        </p>
        <h3>
            Prims Algorithm visulaization 
        </h3>
        <div id="canvas-result"></div>
        <h3>
            Prim's Algorithm psuedo code :-
        </h3>



        <p>
            
            
            prims_algo(Graph pa) { <br/>
                &emsp;for vertexes v in pa:<br/>
                &emsp;&emsp;v.dist = INF<br/>
                &emsp;St = pa.startingnode()<br/>
                &emsp;St.dist = 0<br/>
                
            &emsp;    mst = {}<br/>
            &emsp;    heap = buildHeap(pa.vertices – {St})<br/>
            &emsp;    for each vertex v in St.neighbors():<br/>
            &emsp;     &emsp;   v.dist = pa.weight(St, v)<br/>
            &emsp;     &emsp;   v.previous = St<br/>
            &emsp;     &emsp;   heap.decreaseKey(v, v.dist)<br/>
            &emsp;    while (! heap.empty()):<br/>
            &emsp;     &emsp;   v = heap.deleteMin()<br/>
            &emsp;     &emsp;   mst.addEdge(v, v.previous)<br/>
            &emsp;     &emsp;   for edges (v, u) in pa:<br/>
            &emsp;     &emsp;     &emsp;  d1 = v.dist<br/>
            &emsp;     &emsp;     &emsp;  d2 = u.dist<br/>
            &emsp;     &emsp;     &emsp;  if (d1 < d2):<br/>
            &emsp;     &emsp;     &emsp;    &emsp;  u.previous = v  <br/>
        </p>
        <h3>
            Pros and Cons of Prim's Algorithm
        </h3>
        <h4>
            Pros:
        </h4>

        <p>
            
            1) Easy to understand.<br/>
            2) Root node is selected so clear about the 
            starting node.<br/>
        </p>
        
        <h4>
            Cons:
        </h4>
        <p>
            1) The time it takes to find the least weight arc slows it down for big numbers of nodes.<br/>
            2) Equal weighted edge can add complexity if one of the weights in the cycle is removed and the vertices are connected.<br/>
            3) Prim’s algorithm can fails for Directed Graph : <br/>
       
        
            &emsp; In a directed graph not every node is reachable from every other node. So Prim's algorithm fails for this reason. For example, in below-directed graph let’s assume the starting node is “D”.
            <br/>
        </p>
        
        <img src="../src/Screenshot 2022-08-17 230217.png" alt="SS" >

        <h3>
            Applications of Prim’s Algorithm:
         

        </h3>
        <p>
            1. City center distance for transit minimum route calculation.            <br/>
            
            2. In a network setup, cables play an important role in determining the minimum number of cables required to cover an entire area.            <br/>
            
            3. Cluster Analysis: The k-clustering problem can be viewed as taking the MST and removing the k-1 most expensive edges.<br/>
            
            4. It can be used in the path-finding algorithm which is used in AI.<br/>
            
            5. Prim’s Algorithm can be used in game development like maze games.            <br/>
            
            6. It helps to create a log on the network cycle.            <br/>

        </p>


        <h3>
            Conclusion 
        </h3>
        <p>

            We saw how Prim's algorithm uses the greedy approach to build a minimum spanning tree. A greedy algorithm makes it easy to pick the edge with the lowest weight. We also analyzed how the minimum heap is chosen and the tree is formed. The time complexity of this algorithm has also been discussed and we have also seen how this algorithm is achieved. This makes the Prims algorithm a good greedy approach to finding a minimum spanning tree.
 
        </p>
       </ul> 
       
    </div>

</body>
</html>
